from pathlib import Path
import shutil
import re

from .logger import CuratorLogger
from .repository import RepositoryManager
from .spec_manager import SpecManager
from . import utils


def get_injector(
    logger: CuratorLogger, repo_manager: RepositoryManager, spec_manager: SpecManager
) -> "SpiInjector":
    """
    Factory method to create a subclass of a Injector which is tuned to
    configure an science-platform-images deployment based on a curator spec.

    Conceptually another subclass of Injector could be created to inject into
    a different image building system.
    """
    return SpiInjector(logger, repo_manager, spec_manager)


def get_ingest_name(image_name: str) -> str:
    """Name of spec when added to curator ingest directory."""
    # replace spaces, dots, etc. with "-"
    ingestified = re.sub("[^0-9a-zA-Z-]", "-", image_name)
    return "nbc-" + ingestified + ".yaml"


class SpiInjector:
    """
    A class for interacting with a Science Platform Images (SPI) respository,
    which includes finding extra package requirements for the curated environment
    and also updating the repository deployment with the final package requirements
    generated by the spec.
    """

    _url = "https://github.com/spacetelescope/science-platform-images.git"

    def __init__(
        self,
        logger: CuratorLogger,
        repo_manager: RepositoryManager,
        spec_manager: SpecManager,
    ):
        self.logger = logger
        self.repo_manager = repo_manager
        self.spec_manager = spec_manager
        self.spi_path = Path(repo_manager.repos_dir) / self.repo_name
        self.deployment_name = self.spec_manager.deployment_name
        self.kernel_name = self.spec_manager.kernel_name
        self.base_ingest_branch = "nbc-spec-ingest"
        self.ingest_dir = Path(".nbc-spec-ingest")
        self.archive_dir = Path("nbc-spec-archive")
        self.deployments_path = self.spi_path / "deployments"
        self.deployment_path = self.deployments_path / self.deployment_name
        self.environments_path = self.deployment_path / "environments"
        self.kernel_path = self.environments_path / self.kernel_name
        self.test_path = self.kernel_path / "tests"
        self.env_pip = self.kernel_path / f"{self.kernel_name}.pip"
        self.env_yml = self.kernel_path / f"{self.kernel_name}.yml"
        self.pip_patterns = [
            self.deployments_path / "common/common-env/*.pip",
            self.kernel_path / "*.pip",
        ]
        self.mamba_patterns = [
            self.deployments_path / "common/common-env/*.conda",
            self.kernel_path / "*.conda",
            self.deployments_path / "common/common-env/*.mamba",
            self.kernel_path / "*.mamba",
        ]

    @property
    def url(self):
        return self.spec_manager.spi_url or self._url

    @property
    def repo_name(self):
        name = self.url.split("/")[-1]
        return name.split(".")[0]

    def submit_for_build(self):
        new_ingest_branch = self.base_ingest_branch + "-" + utils.hex_time()
        ingest_name = get_ingest_name(self.spec_manager.image_name)
        title = f"Curator spec for build {ingest_name}."
        message = f"""
Added curator spec {ingest_name} for {self.spec_manager.deployment_name}.
Hash: {self.spec_manager.sha256}
Description:
{self.spec_manager.description}
        """

        if not self.add_to_ingest(self.base_ingest_branch, ingest_name, new_ingest_branch, message):
            return False

        if not self.push_and_pr(self.base_ingest_branch, new_ingest_branch, title, message):
            return False

        return self.logger.info("Spec submission complete.")

    def add_to_ingest(
        self,
        base_ingest_branch: str,
        ingest_name: str,
        new_ingest_branch: str,
        message: str,
    ) -> bool | str:
        """During GitHub actions, copy the spec from the ingest directory
        to an archive location with a more recognizable name.
        """
        self.logger.info(
            f"Adding spec to ingest directory {self.ingest_dir} on branch {new_ingest_branch}."
        )
        self.logger.debug(
            "Branching repo {self.repo} from {base_ingest_branch} to {new_ingest_branch}."
        )
        if not self.repo_manager.branch_repo(
            self.repo_name, new_ingest_branch, base_ingest_branch
        ):
            return False
        (self.spi_path / self.ingest_dir).mkdir(exist_ok=True, parents=True)
        spec_dest = self.ingest_dir / ingest_name
        shutil.copy(self.spec_manager.spec_file, self.spi_path / spec_dest)
        if not self.repo_manager.git_add(self.repo_name, spec_dest):
            return False
        if not self.repo_manager.git_commit(self.repo_name, message):
            return False
        return True

    def push_and_pr(
        self, base_ingest_branch: str, new_ingest_branch: str, title: str, message: str
    ):
        self.logger.info(f"Pushing submission branch {new_ingest_branch}....")
        if not self.repo_manager.git_push(self.repo_name, new_ingest_branch):
            return False

        self.logger.info("Creating PR...")
        if not self.repo_manager.github_create_pr(
            self.repo_name, base_ingest_branch, title, message
        ):
            return False

        self.logger.info("Merging PR...")
        if not self.repo_manager.github_merge_pr(
            self.repo_name, base_ingest_branch, title, message
        ):
            return False

        return True

    # def archive_curator_spec(self) -> bool:
    #     """During GitHub actions, copy the spec from the ingest directory
    #     to an archive location with a more recognizable name.
    #     """
    #     source_dir = self.spi_path / ".spec-ingest"
    #     source = list(source_dir.glob("*.yaml"))[0]
    #     dest = self.spi_path / ".spec-archive" / self.deployment_name / source.name
    #     dest.parent.mkdir(parents=True, exist_ok=True)
    #     shutil.copy(source, dest)
    #     return True

    def set_curator_spec(self) -> bool:
        """Write out the curator environment spec with a generic name."""
        out_spec = self.environments_path / "nb-curator-spec.yaml"
        self.logger.info("Saving spec to SPI environments dir: ", out_spec)
        return self.spec_manager.save_spec(out_spec)

    def inject(self) -> bool:
        """
        Performs a placeholder injection of the SPI.
        In a real implementation, this would gather information about
        the Python environment, installed packages, Jupyter kernels, etc.
        """
        self.logger.info(
            f"Initiating SPI injection into {self.spi_path} for {self.deployment_name} kernel {self.kernel_name}..."
        )
        self._inject("notebook_repo_urls", self.environments_path / "notebook-repos")
        self._inject("mamba_spec", self.env_yml)
        self._inject("pip_compiler_output", self.env_pip)
        self._inject("test_imports", self.test_path / "imports")
        self._inject("test_notebooks", self.test_path / "notebooks")
        return self.logger.info("SPI injection complete.")

    def _inject(self, field: str, where: str | Path) -> None:
        self.logger.info(f"Injecting field {field} to {where}")
        with open(str(where), "w") as f:
            obj = self.spec_manager.get_output_data(field)
            if isinstance(obj, dict):
                utils.get_yaml().dump(obj, f)
            elif isinstance(obj, list):
                f.write("\n".join(obj))
            elif isinstance(obj, str):
                f.write(obj)
            else:
                raise ValueError(f"Unsupported type {type(obj)} for field {field}")

    def get_spi_requirements(self, glob_patterns: list[Path], kind: str) -> list[Path]:
        """Find extra mamba or pip requirements files required by SPI environments such as those
        included in the common/common-env directory. mamba packages are typically non-Python packages
        such as C libraries and compiles and install tools.  For Python packages,  using
        pip to install them is preferred.
        """
        spi_extra_requirements = []
        for pattern in glob_patterns:
            extras = Path(".").glob(str(pattern))
            for path in extras:
                spi_extra_requirements.append(path)
                self.logger.debug(
                    f"Found SPI {kind} requirements file {path} based on glob '{pattern}'"
                )
        self.logger.info(
            f"Found SPI extra {len(spi_extra_requirements)} {kind} requirements files."
        )
        return spi_extra_requirements

    def find_spi_pip_files(self) -> list[Path]:
        self.env_pip.unlink(missing_ok=True)
        return self.get_spi_requirements(self.pip_patterns, "pip")

    def find_spi_mamba_files(self) -> list[Path]:
        self.env_yml.unlink(missing_ok=True)
        return self.get_spi_requirements(self.mamba_patterns, "mamba")
